<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Robust System Prompt</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-section { border: 1px solid #ccc; padding: 15px; margin: 10px 0; }
        .content-display { 
            white-space: pre-line; 
            font-family: 'Courier New', monospace; 
            font-size: 12px; 
            line-height: 1.4;
            background: #f9f9f9;
            padding: 10px;
            border: 1px solid #ddd;
            max-height: 400px;
            overflow-y: auto;
        }
        button { 
            background: #4caf50; 
            color: white; 
            border: none; 
            padding: 10px 20px; 
            margin: 10px 5px; 
            cursor: pointer; 
            border-radius: 5px;
        }
        button:hover { background: #45a049; }
        .status { margin: 10px 0; padding: 10px; border-radius: 5px; }
        .success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .warning { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        .test-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .test-case { border: 1px solid #ddd; padding: 10px; margin: 5px 0; }
        .test-case h4 { margin: 0 0 10px 0; color: #333; }
    </style>
</head>
<body>
    <h1>Test Robust System Prompt Implementation</h1>
    <p>This test verifies that the ultra-precise editorial engine follows strict enterprise-style editing rules.</p>
    
    <div>
        <button onclick="testSurgicalPrecision()">Test Surgical Precision</button>
        <button onclick="testFormatPreservation()">Test Format Preservation</button>
        <button onclick="testLiteralEdits()">Test Literal Edits</button>
        <button onclick="testSinglePageConstraint()">Test Single Page Constraint</button>
        <button onclick="testAllScenarios()">Test All Scenarios</button>
    </div>
    
    <div id="status"></div>
    
    <div class="test-section">
        <h3>Test Results:</h3>
        <div id="test-results" class="content-display">Click a test button to see the results...</div>
    </div>

    <script>
        const statusDiv = document.getElementById('status');
        const testResultsDiv = document.getElementById('test-results');
        
        function log(message, type = 'info') {
            statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
            console.log(message);
        }
        
        async function generateInitialNFA() {
            const requestData = {
                subject: "Chess Tournament",
                summary: "Chess tournament organized by Panchatantra club on 5th September 2025 at RV University Campus. The event will feature competitive chess matches among students and faculty, promoting strategic thinking and community engagement through chess activities.",
                nfaType: "reimbursement",
                bulletsRequired: true,
                tableData: [
                    ["slno", "item", "unit", "total"],
                    ["1", "prize", "2", "20"],
                    ["2", "certificate", "50", "25"],
                    ["3", "refreshment", "100", "30"],
                    ["Total", "", "", "75"]
                ]
            };
            
            const response = await fetch('http://localhost:5000/api/generate-nfa', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestData),
            });
            
            const result = await response.json();
            return result;
        }
        
        async function testSurgicalPrecision() {
            try {
                log("üîÑ Testing surgical precision edits...", 'info');
                
                const initialResult = await generateInitialNFA();
                if (!initialResult.success) {
                    throw new Error("Failed to generate initial NFA");
                }
                
                const originalContent = initialResult.nfaText;
                let allResults = `=== SURGICAL PRECISION TEST ===\n\n`;
                allResults += `Original Content:\n${originalContent}\n\n`;
                
                // Test surgical precision scenarios
                const scenarios = [
                    {
                        name: "Subject Change Only",
                        request: "Change the subject line to 'Teacher's Day Celebration'",
                        expectedBehavior: "Only subject line should change, everything else preserved"
                    },
                    {
                        name: "Date Replacement",
                        request: "Replace all instances of '5th September' with '15th October'",
                        expectedBehavior: "Only date references should change"
                    },
                    {
                        name: "Word Replacement",
                        request: "Replace all instances of 'chess' with 'chess game'",
                        expectedBehavior: "Only 'chess' words should be replaced with 'chess game'"
                    }
                ];
                
                for (const scenario of scenarios) {
                    const editRequest = {
                        text: originalContent,
                        prompt: scenario.request,
                        subject: "Chess Tournament",
                        summary: "Chess tournament organized by Panchatantra club",
                        nfaType: "reimbursement",
                        bulletsRequired: true,
                        tableData: [["slno", "item", "unit", "total"]]
                    };
                    
                    const editResponse = await fetch('http://localhost:5000/api/edit-nfa', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(editRequest),
                    });
                    
                    const editResult = await editResponse.json();
                    
                    if (editResult.success) {
                        const updatedContent = editResult.editedText;
                        allResults += `--- ${scenario.name} ---\n`;
                        allResults += `Request: "${scenario.request}"\n`;
                        allResults += `Expected: ${scenario.expectedBehavior}\n`;
                        allResults += `Result: ${updatedContent}\n\n`;
                        
                        // Analyze if the edit was surgical
                        const isSurgical = analyzeSurgicalPrecision(originalContent, updatedContent, scenario.request);
                        allResults += `Surgical Analysis: ${isSurgical}\n\n`;
                    } else {
                        allResults += `‚ùå ${scenario.name}: REQUEST FAILED - ${editResult.error}\n\n`;
                    }
                }
                
                testResultsDiv.textContent = allResults;
                log("‚úÖ Surgical precision test completed", 'success');
                
            } catch (error) {
                log(`‚ùå Error testing surgical precision: ${error.message}`, 'error');
                testResultsDiv.textContent = `Error: ${error.message}`;
            }
        }
        
        async function testFormatPreservation() {
            try {
                log("üîÑ Testing format preservation...", 'info');
                
                const initialResult = await generateInitialNFA();
                if (!initialResult.success) {
                    throw new Error("Failed to generate initial NFA");
                }
                
                const originalContent = initialResult.nfaText;
                let allResults = `=== FORMAT PRESERVATION TEST ===\n\n`;
                allResults += `Original Content:\n${originalContent}\n\n`;
                
                // Test format preservation scenarios
                const scenarios = [
                    {
                        name: "Add Bullet Point",
                        request: "Add a bullet point about prize distribution",
                        expectedBehavior: "Should add bullet while preserving existing format"
                    },
                    {
                        name: "Shorten Content",
                        request: "Shorten the request paragraph to 2 sentences",
                        expectedBehavior: "Should shorten only the request paragraph, preserve other formatting"
                    },
                    {
                        name: "Modify Conclusion",
                        request: "Change the conclusion to mention advance payment",
                        expectedBehavior: "Should modify only conclusion, preserve other sections"
                    }
                ];
                
                for (const scenario of scenarios) {
                    const editRequest = {
                        text: originalContent,
                        prompt: scenario.request,
                        subject: "Chess Tournament",
                        summary: "Chess tournament organized by Panchatantra club",
                        nfaType: "reimbursement",
                        bulletsRequired: true,
                        tableData: [["slno", "item", "unit", "total"]]
                    };
                    
                    const editResponse = await fetch('http://localhost:5000/api/edit-nfa', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(editRequest),
                    });
                    
                    const editResult = await editResponse.json();
                    
                    if (editResult.success) {
                        const updatedContent = editResult.editedText;
                        allResults += `--- ${scenario.name} ---\n`;
                        allResults += `Request: "${scenario.request}"\n`;
                        allResults += `Expected: ${scenario.expectedBehavior}\n`;
                        allResults += `Result: ${updatedContent}\n\n`;
                        
                        // Analyze format preservation
                        const formatPreserved = analyzeFormatPreservation(originalContent, updatedContent);
                        allResults += `Format Analysis: ${formatPreserved}\n\n`;
                    } else {
                        allResults += `‚ùå ${scenario.name}: REQUEST FAILED - ${editResult.error}\n\n`;
                    }
                }
                
                testResultsDiv.textContent = allResults;
                log("‚úÖ Format preservation test completed", 'success');
                
            } catch (error) {
                log(`‚ùå Error testing format preservation: ${error.message}`, 'error');
                testResultsDiv.textContent = `Error: ${error.message}`;
            }
        }
        
        async function testLiteralEdits() {
            try {
                log("üîÑ Testing literal edit behavior...", 'info');
                
                const initialResult = await generateInitialNFA();
                if (!initialResult.success) {
                    throw new Error("Failed to generate initial NFA");
                }
                
                const originalContent = initialResult.nfaText;
                let allResults = `=== LITERAL EDITS TEST ===\n\n`;
                allResults += `Original Content:\n${originalContent}\n\n`;
                
                // Test literal edit scenarios
                const scenarios = [
                    {
                        name: "Global Replacement",
                        request: "Replace all instances of 'tournament' with 'competition'",
                        expectedBehavior: "Should replace ALL instances of 'tournament' with 'competition'"
                    },
                    {
                        name: "Case-Sensitive Replacement",
                        request: "Replace 'RV University' with 'RVU'",
                        expectedBehavior: "Should replace exact case matches only"
                    },
                    {
                        name: "Multiple Word Replacement",
                        request: "Replace 'strategic thinking' with 'analytical skills'",
                        expectedBehavior: "Should replace the exact phrase"
                    }
                ];
                
                for (const scenario of scenarios) {
                    const editRequest = {
                        text: originalContent,
                        prompt: scenario.request,
                        subject: "Chess Tournament",
                        summary: "Chess tournament organized by Panchatantra club",
                        nfaType: "reimbursement",
                        bulletsRequired: true,
                        tableData: [["slno", "item", "unit", "total"]]
                    };
                    
                    const editResponse = await fetch('http://localhost:5000/api/edit-nfa', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(editRequest),
                    });
                    
                    const editResult = await editResponse.json();
                    
                    if (editResult.success) {
                        const updatedContent = editResult.editedText;
                        allResults += `--- ${scenario.name} ---\n`;
                        allResults += `Request: "${scenario.request}"\n`;
                        allResults += `Expected: ${scenario.expectedBehavior}\n`;
                        allResults += `Result: ${updatedContent}\n\n`;
                        
                        // Analyze literal edit behavior
                        const literalEdit = analyzeLiteralEdits(originalContent, updatedContent, scenario.request);
                        allResults += `Literal Analysis: ${literalEdit}\n\n`;
                    } else {
                        allResults += `‚ùå ${scenario.name}: REQUEST FAILED - ${editResult.error}\n\n`;
                    }
                }
                
                testResultsDiv.textContent = allResults;
                log("‚úÖ Literal edits test completed", 'success');
                
            } catch (error) {
                log(`‚ùå Error testing literal edits: ${error.message}`, 'error');
                testResultsDiv.textContent = `Error: ${error.message}`;
            }
        }
        
        async function testSinglePageConstraint() {
            try {
                log("üîÑ Testing single page constraint handling...", 'info');
                
                const initialResult = await generateInitialNFA();
                if (!initialResult.success) {
                    throw new Error("Failed to generate initial NFA");
                }
                
                const originalContent = initialResult.nfaText;
                let allResults = `=== SINGLE PAGE CONSTRAINT TEST ===\n\n`;
                allResults += `Original Content:\n${originalContent}\n\n`;
                
                // Test single page constraint scenarios
                const scenarios = [
                    {
                        name: "Add Extensive Content",
                        request: "Add detailed information about chess rules, tournament format, and participant requirements",
                        expectedBehavior: "Should add content but keep it concise to maintain single page"
                    },
                    {
                        name: "Expand Bullet Points",
                        request: "Expand all bullet points to be more detailed",
                        expectedBehavior: "Should expand but maintain single page constraint"
                    },
                    {
                        name: "Add Multiple Sections",
                        request: "Add sections for timeline, budget breakdown, and risk assessment",
                        expectedBehavior: "Should add sections but keep them minimal for single page"
                    }
                ];
                
                for (const scenario of scenarios) {
                    const editRequest = {
                        text: originalContent,
                        prompt: scenario.request,
                        subject: "Chess Tournament",
                        summary: "Chess tournament organized by Panchatantra club",
                        nfaType: "reimbursement",
                        bulletsRequired: true,
                        tableData: [["slno", "item", "unit", "total"]]
                    };
                    
                    const editResponse = await fetch('http://localhost:5000/api/edit-nfa', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(editRequest),
                    });
                    
                    const editResult = await editResponse.json();
                    
                    if (editResult.success) {
                        const updatedContent = editResult.editedText;
                        allResults += `--- ${scenario.name} ---\n`;
                        allResults += `Request: "${scenario.request}"\n`;
                        allResults += `Expected: ${scenario.expectedBehavior}\n`;
                        allResults += `Result: ${updatedContent}\n\n`;
                        
                        // Analyze single page constraint handling
                        const constraintHandled = analyzeSinglePageConstraint(originalContent, updatedContent);
                        allResults += `Constraint Analysis: ${constraintHandled}\n\n`;
                    } else {
                        allResults += `‚ùå ${scenario.name}: REQUEST FAILED - ${editResult.error}\n\n`;
                    }
                }
                
                testResultsDiv.textContent = allResults;
                log("‚úÖ Single page constraint test completed", 'success');
                
            } catch (error) {
                log(`‚ùå Error testing single page constraint: ${error.message}`, 'error');
                testResultsDiv.textContent = `Error: ${error.message}`;
            }
        }
        
        async function testAllScenarios() {
            try {
                log("üîÑ Running comprehensive test of all robust system prompt scenarios...", 'info');
                
                const initialResult = await generateInitialNFA();
                if (!initialResult.success) {
                    throw new Error("Failed to generate initial NFA");
                }
                
                const originalContent = initialResult.nfaText;
                let allResults = `=== COMPREHENSIVE ROBUST SYSTEM PROMPT TEST ===\n\n`;
                allResults += `Original Content:\n${originalContent}\n\n`;
                
                // Test all scenarios from the robust system prompt
                const comprehensiveScenarios = [
                    {
                        name: "Explicit Subject Change",
                        request: "Change the subject line to 'Leave Request' and date to '2025-09-22'",
                        expectedBehavior: "Edit subject and date only; preserve everything else"
                    },
                    {
                        name: "Global Replacement",
                        request: "Replace all instances of 'Manager' with 'Team Lead'",
                        expectedBehavior: "Do a global literal replacement only"
                    },
                    {
                        name: "Word Count Constraint",
                        request: "Shorten the summary to 40 words",
                        expectedBehavior: "Shorten only the summary section to exactly ~40 words; keep formatting"
                    },
                    {
                        name: "Ambiguous Request",
                        request: "Make it better",
                        expectedBehavior: "Pick least-invasive interpretation and execute it"
                    },
                    {
                        name: "Pattern Not Found",
                        request: "Replace 'NonExistentWord' with 'NewWord'",
                        expectedBehavior: "Output original text with changelog explaining 'No changes ‚Äî pattern not found'"
                    }
                ];
                
                let successCount = 0;
                
                for (const scenario of comprehensiveScenarios) {
                    const editRequest = {
                        text: originalContent,
                        prompt: scenario.request,
                        subject: "Chess Tournament",
                        summary: "Chess tournament organized by Panchatantra club",
                        nfaType: "reimbursement",
                        bulletsRequired: true,
                        tableData: [["slno", "item", "unit", "total"]]
                    };
                    
                    const editResponse = await fetch('http://localhost:5000/api/edit-nfa', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(editRequest),
                    });
                    
                    const editResult = await editResponse.json();
                    
                    if (editResult.success) {
                        const updatedContent = editResult.editedText;
                        allResults += `--- ${scenario.name} ---\n`;
                        allResults += `Request: "${scenario.request}"\n`;
                        allResults += `Expected: ${scenario.expectedBehavior}\n`;
                        allResults += `Result: ${updatedContent}\n\n`;
                        
                        // Comprehensive analysis
                        const analysis = analyzeRobustSystemPrompt(originalContent, updatedContent, scenario.request);
                        allResults += `Analysis: ${analysis}\n\n`;
                        
                        successCount++;
                    } else {
                        allResults += `‚ùå ${scenario.name}: REQUEST FAILED - ${editResult.error}\n\n`;
                    }
                }
                
                allResults += `=== SUMMARY ===\n`;
                allResults += `Successful scenarios: ${successCount}/${comprehensiveScenarios.length}\n`;
                allResults += `Success rate: ${(successCount/comprehensiveScenarios.length*100).toFixed(1)}%\n`;
                
                testResultsDiv.textContent = allResults;
                
                if (successCount === comprehensiveScenarios.length) {
                    log(`üéâ PERFECT: All ${comprehensiveScenarios.length} scenarios worked with robust system prompt!`, 'success');
                } else if (successCount >= comprehensiveScenarios.length * 0.8) {
                    log(`‚úÖ GOOD: ${successCount}/${comprehensiveScenarios.length} scenarios worked (${(successCount/comprehensiveScenarios.length*100).toFixed(1)}%)`, 'success');
                } else {
                    log(`‚ùå POOR: Only ${successCount}/${comprehensiveScenarios.length} scenarios worked (${(successCount/comprehensiveScenarios.length*100).toFixed(1)}%)`, 'error');
                }
                
            } catch (error) {
                log(`‚ùå Error in comprehensive test: ${error.message}`, 'error');
                testResultsDiv.textContent = `Error: ${error.message}`;
            }
        }
        
        // Analysis functions
        function analyzeSurgicalPrecision(original, updated, request) {
            const changes = [];
            
            // Check if only requested changes were made
            if (request.includes("subject")) {
                const originalSubject = original.match(/Subject:\s*([^\n]+)/i);
                const updatedSubject = updated.match(/Subject:\s*([^\n]+)/i);
                if (originalSubject && updatedSubject && originalSubject[1] !== updatedSubject[1]) {
                    changes.push("Subject changed as requested");
                }
            }
            
            if (request.includes("replace") && request.includes("instances")) {
                // Check for global replacement
                const replacePattern = request.match(/Replace all instances of '([^']+)' with '([^']+)'/);
                if (replacePattern) {
                    const [, from, to] = replacePattern;
                    const originalCount = (original.match(new RegExp(from, 'g')) || []).length;
                    const updatedCount = (updated.match(new RegExp(to, 'g')) || []).length;
                    if (updatedCount > 0 && !updated.includes(from)) {
                        changes.push(`Global replacement applied: '${from}' ‚Üí '${to}'`);
                    }
                }
            }
            
            return changes.length > 0 ? `‚úÖ Surgical precision: ${changes.join(', ')}` : '‚ùå Not surgical - unexpected changes detected';
        }
        
        function analyzeFormatPreservation(original, updated) {
            const originalLines = original.split('\n');
            const updatedLines = updated.split('\n');
            
            // Check if structure is preserved
            const structurePreserved = Math.abs(originalLines.length - updatedLines.length) <= 2;
            const hasSubjectLine = updated.includes('Subject:');
            const hasRequestParagraph = updated.includes('Request for approval');
            const hasConclusion = updated.includes('submitted for approval');
            
            if (structurePreserved && hasSubjectLine && hasRequestParagraph && hasConclusion) {
                return '‚úÖ Format preserved - structure maintained';
            } else {
                return '‚ùå Format not preserved - structure changed';
            }
        }
        
        function analyzeLiteralEdits(original, updated, request) {
            if (request.includes("Replace all instances")) {
                const replacePattern = request.match(/Replace all instances of '([^']+)' with '([^']+)'/);
                if (replacePattern) {
                    const [, from, to] = replacePattern;
                    const originalInstances = (original.match(new RegExp(from, 'g')) || []).length;
                    const updatedInstances = (updated.match(new RegExp(to, 'g')) || []).length;
                    
                    if (updatedInstances >= originalInstances && !updated.includes(from)) {
                        return `‚úÖ Literal replacement successful: ${originalInstances} instances replaced`;
                    } else {
                        return `‚ùå Literal replacement failed: expected ${originalInstances}, got ${updatedInstances}`;
                    }
                }
            }
            
            return '‚úÖ Literal edit behavior confirmed';
        }
        
        function analyzeSinglePageConstraint(original, updated) {
            const originalLength = original.length;
            const updatedLength = updated.length;
            const lengthRatio = updatedLength / originalLength;
            
            // Single page constraint should keep content concise
            if (lengthRatio <= 1.5) { // Allow up to 50% increase
                return `‚úÖ Single page constraint respected: ${originalLength} ‚Üí ${updatedLength} chars (${(lengthRatio*100).toFixed(1)}%)`;
            } else {
                return `‚ùå Single page constraint violated: ${originalLength} ‚Üí ${updatedLength} chars (${(lengthRatio*100).toFixed(1)}%)`;
            }
        }
        
        function analyzeRobustSystemPrompt(original, updated, request) {
            const analyses = [];
            
            // Check surgical precision
            const surgical = analyzeSurgicalPrecision(original, updated, request);
            analyses.push(surgical);
            
            // Check format preservation
            const format = analyzeFormatPreservation(original, updated);
            analyses.push(format);
            
            // Check single page constraint
            const constraint = analyzeSinglePageConstraint(original, updated);
            analyses.push(constraint);
            
            return analyses.join(' | ');
        }
        
        // Auto-run health check on page load
        window.onload = () => {
            setTimeout(() => {
                log("üîÑ Testing server health...", 'info');
                fetch('http://localhost:5000/api/health')
                    .then(response => response.json())
                    .then(result => {
                        log(`‚úÖ Health check: ${JSON.stringify(result)}`, 'success');
                    })
                    .catch(error => {
                        log(`‚ùå Health check failed: ${error.message}`, 'error');
                    });
            }, 1000);
        };
    </script>
</body>
</html>
